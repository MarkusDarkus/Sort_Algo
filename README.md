# Sort_Algo

## Hello Mr Bogdan. We want to represent to you our great work in algorithm science!!!
## Sorting

### Insrtion Sort
Сортировка вставками. Строит отсортированную последовательность, путем постепенного включения элементов из исходного массива.

* Лучший случай - Omega(n)
* Худший случай - O(n^2)
* Средний случай - O(n^2)
* Память - O(1)
* Стабильность - YES
### Selection Sort
Сортировка выбором. Методом итерации находит минимальный (или максимальный) элемент в неотсортированной части массива и перемещает его в начало (или конец) отсортированной части. Также для этого алгоритма не требуется дополнительной памяти.

* Лучший случай - Omega(n)
* Худший случай - O(n^2)
* Средний случай - O(n^2)
* Память - O(1)
* Стабильность - NO

### Bubble Sort
Сортировка пузырьком. Называется так из-за характерного движения элементов, "всплывающих" к верхней части массива.

* Лучший случай - Omega(n)
* Худший случай - O(n^2)
* Средний случай - O(n^2)
* Память - O(1)
* Стабильность - YES
### Gnome Sort
Гномья сртировка. Так назван из-за своего поведения: он перемещается по массиву подобно гному, и проверяет, нужно ли два соседних элемента поменять местами. Если нужно, то гном их меняет, иначе движется дальше. Пока не дойдет до конца.

* Лучший случай - Omega(n)
* Худший случай - O(n^2)
* Средний случай - O(n^2)
* Память - O(1)
* Стабильность - YES
### COCKtail Sort
Сортировка перемешиванием. Усовершенствованный вариант сортировки пузырьком. Устраняет её недостатки, также уменьшает число проходов по массиву. В сортировке перемешиванием элементы сравниваются и перемещаются в обоих направлениях (от начала к концу и обратно)

* Лучший случай - Omega(n)
* Худший случай - O(n^2)
* Средний случай - O(n^2)
* Память - O(1)
* Стабильность - YES
### HeapSort
Сортировка кучей. Основан на структуре Куча. Очевидно эффективный алгоритм, особенно для массивов с большим колличеством данных.

* Лучший случай - Omega(n log n)
* Худший случай - O(n log n)
* Средний случай - O(n log n)
* Память - O(1)
* Стабильность - NO
### QuickSort
Быстрая сортировка( Сортировка Хоара ). Эффективный алгоритм, основанный на принципе "разделяй и властвуй". Работает путем выбора опроного разделителя (pivot) массива на подгруппы, большие pivot, меньшие и равные ему. Затем каждая из групп сортируется рукурсивно. Хороша для больших данных.

* Лучший случай - Omega(n log n)
* Худший случай - O(n^2)
* Средний случай - O(n log n)
* Память - O(log n)
* Стабильность - NO
### Merge Sort
Сортировка слиянием. Эффективный алгоритм, фндаментальный. Работает рекурсивно, допуская сортировку как больших так и небольших объемов данных.

* Лучший случай - Omega(n log n)
* Худший случай - O(n log n)
* Средний случай - O(n log n)
* Память - O(n)
* Стабильность - YES
### Tree Sort
Сортировка двоичным деревом. Использует структуру двоичного дерева для упорядочивания элементов. Принцип: создание дерева, в котором меньшие элементы находятся в левом поддереве, а большие в правом. Для сортировки - элементы вставляются в дерево. Затем - обход дерева в порядке возрастания, что дает осортированный результат. Хорош для больших данных.

* Лучший случай - Omega(n log n)
* Худший случай - O(n^2)
* Средний случай - O(n log n)
* Память - O(n)
* Стабильность - NO
### Counting Sort
Сортировка подсчетом. Основана на сортировке Тони Хоара.
k - диапазон значений в массиве.

* Лучший случай - Omega(n + k)
* Худший случай - O(n + k)
* Средний случай - O(n + k)
* Память - O(n + k)
* Стабильность - YES
### Comb Sort
Сортировка расческой. Улучшенная версия сортировки пузырьком, которая позволяет более эффективно перемещать элементы в массиве.

* Лучший случай - Omega(n log n)
* Худший случай - O(n^2)
* Средний случай - O(n^2)
* Память - O(1)
* Стабильность - NO
### ShellSort
Сортировка Шелла. Улучшенный алгоритм сортировки вставками, использующий последовательность инкрементов для эффективной сортировки элементов в массиве.

* Лучший случай - Omega(n log^2 n)
* Худший случай - O(n^2)
* Средний случай - O(n^(1.25))
* Память - O(1)
* Стабильность - NO
### Bucket Sort
Сортировка с использованием корзин. Разбивает входный массив на равные интервалы(корзины), распределяет элементы по соответвующим корзинам, затем отдельно сортирует каждую корзину(часто с использованием другого сортировочного алгоритма или рекурсивно применяя сортировку с использованием корзин)

* Лучший случай - Omega(n + k)
* Худший случай - O(n^2)
* Средний случай - O(n)
* Память - O(т + л)
* Стабильность - YES
